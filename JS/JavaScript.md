# JS

1. [Хорошие практики](#1)
2. [Именование переменных](#2)
3. [Именование функций](#3)
7. [Архитектура](#4)
8. [Безопасность](#5)

<a name="1"></a>

## Хорошие практики

<a name="1.1"></a>

- [1.1](#1.1) Читаемость первостепенна

  Любое решение в первую очередь должно быть понятным и разбитым на логичные части, чтобы другие члены команды могли
  разобраться не только в назначении кода, но и в применяемых решениях без дополнительных оговорок.

<a name="1.2"></a>

- [1.2](#1.2) Все, что может быть написано на чистых html+css в рамках тех свойств, что дают заявленные браузеры -
  должно быть написано без применения JS.

  > _Это правило не должно противоречить предыдущему пункту_

  Это очень важное правило, так как:

    - Часто излишнее использование скриптов вводит других разработчиков в заблуждение, особенно, когда посреди работы
      скрипт внезапно меняет какие-либо свойства элемента.

    - Это уменьшает производительность веб-приложения.

    - Как правило код, написанный на html+css, гораздо проще изменять.

  Если реализация функционала на html+css возможна только с применением разных хаков, то тут уже стоит переходить на JS,
  чтобы поддерживаемость проекта не падала

<a name="1.3"></a>

- [1.3](#1.3) Методы.

  **Именование**:

  Имя метода должно быть `self descriptive`(описывать само себя). Из названия должно быть понятно для чего нужен метод и
  что он делает. Не должно быть причин задумываться о его внутренней реализации.

  **Параметры**:

  Если в метод необходимо передать много параметров, объединяйте их в один объект. Например, у вас есть метод, который
  рисует прямоугольник принимая координаты точек, ширину, высоту, цвет, толщину рамок и другие параметры. В таком
  случае, проще будет передать один объект ‘options’. Это снимет с нас обязанность держать в голове все параметры, а
  также их порядок, и позволит удобно сделать многие свойства с дефолтными значениями.

  В случае, когда параметры передаются объектом, получать их значения предпочтительнее с помощью деструктуризации.

  Если параметр опциональный, необходимо ему задать значение по умолчанию.

  **Тело**:

  Соблюдать принцип Single Responsibility. Метод должен выполнять только одну задачу (например, метод `createReport`,
  который создает отчет и отправляет его на сервер необходимо разделить на два: `createReport` и `sendReport`).

  Метод должен быть компактным. Обычно, длина метода варьируется в пределах 10-40 строк. Это не значит что ваш метод
  обязательно должен должен быть в таких рамках, но если ваш метод занимает 200 строк, это повод задуматься о том, можно
  ли его разделить на несколько отдельных методов. Про компактность методов можно почитать у С. Макконела “Совершенный
  код” и Р. Мартина “Чистый код”. Так
  же [здесь](https://softwareengineering.stackexchange.com/questions/133404/what-is-the-ideal-length-of-a-method-for-you)
  Неплохое рассуждение о размерах метода.

<a name="1.4"></a>

- [1.4](#1.4) Делайте время жизни переменных как можно короче.

  Объявление переменной должно быть рядом с местом ее использования. Это дает более быстрое понимание того, что
  происходит в коде, плюс снижается вероятность неправильного использования переменной или ее перезапись.

  Более подробнее про время жизни переменной можно прочитать у С. Макконнелла в "Совершенном коде".

<a name="1.5"></a>

- [1.5](#1.5) Все кнопки сабмита должны быть внутри `<form>` вместе со всеми соответсвующими инпутами. Обработку завершения заполнения вешать на событие `submit` формы, а не клик по кнопке.

  Это очень важное правило для UX. Еще раз: не вешайте обработку заполнения формы на событие `click` у кнопки, а вешайте на событие `submit` у формы. Как минимум, `submit` формы может быть вызван дополнительными путями - например, нажатие на enter у любого `input`, и, совершая ошибку, вы серьезно нарушаете UX всего сайта.

<a name="1.6"></a>

- [1.6](#1.6) Все проверки содержащие более одного условия должны быть вынесены.
  Выносить в отдельную архитектурную единицу - переменную или функцию.

  Плохо:

  ```javascript
    if ((this.allowUpdate) && ((user.isAdmin) || (user.role === item.owner)) {
      this.update(item.data);
    }
  ```

  Хорошо:

  ```javascript
    function isUpdateAllowedForUser(user, item) {
      return (this.allowUpdate) && ((user.isAdmin) || (user.role === item.owner);
    }
    //.. в нужном месте
    if (this.isUpdateAllowedForUser(user, item)) {
      this.update(item.data);
    }
  ```

  Тоже хорошо (пример ветвистого кода с кучей условий, где все именованно и раскидано, а поэтому понятно)

  ```javascript
    const isTodayRequested = day === 'today';
    const isTomorrowRequested = day === 'tomorrow';
    const isDepartTomorrow = departure.day() !== now.day() && unix(departure)  unix(now);
    const isDepartToday = departure.day() === now.day();
    const isRequestedDayIncorrect = (isDepartToday && !isTodayRequested) || (isDepartTomorrow && !isTomorrowRequested);
    const result = isRequestedDayIncorrect ? getPreviousDay(day) : day;
  ```

  Вынос условий и их раскидывание по разным функциям/переменным позволяет каждому условию дать человеческое имя и потом ваши коллеги могут удобно читать все логические взаимосвязи не в шифре, а в удобном виде, почти как художественный текст.

<a name="1.7"></a>

- [1.7](#1.7) Всегда избегать неявного приведения типов в JS, если где-то не используется TS(например, генератор заданий)

  В нашем любимом языке можно складывать массивы со строками, объекты с числами и тд. Но делать этого, конечно же, не надо. Всегда явно преобразуйте переменные к одному типу при их сложении, вычитании, делении и умножении.

  Плохо:

  ```javascript
  const lifes = [true, false, false, true, true];
  aliveTotal = 0;
  for (let i = 0; i < lifes.length; i++) {
    aliveTotal += lifes[i]; // тут мы к числу прибавляем элемент массива, который boolean.
  }
  ```

  Самое ужасное, что код этот будет работать, но в нем все слишком уязвимо и его чтобы поддерживать, надо постоянно в голове держать, что там булины с числами складываются.

<a name="1.8"></a>

- [1.8](#1.8) Не изменять прототипы стандартных конструкторов (например, `String.prototype` или `Function.prototype`), до тех пор пока вопрос внимательно не изучен и этот трюк не согласован со старшим разработчиком.

<a name="1.9"></a>

- [1.9](#1.9) Конструктор класса должен быть максимально легковесным.

  Например, если требуется провести поиск по DOM-дереву для задания значений полям класса, то нужно вынести этот функционал в отдельный метод. Так же в случае если нужно задать обработчики для событий - в отдельный метод.

<a name="1.10"></a>

- [1.10](#1.10) Выносить обработчики событий в отдельные функции.

  Не стоит создавать анонимные функции прямо в том же месте, где идет привязка к событию.

  Плохо:

  ```javascript
  elem.addEventListener("click", function () {
    alert("Спасибо!");
  });
  ```

  Хорошо:

  ```javascript
  class Component {
    bindEventListeners() {
      topButton.addEventListener("click", this.handleStopButtonClick);
    }

    handleStopButtonClick() {
      // ...
    }
  }
  ```

<a name="1.11"></a>

- [1.11](#1.11) В обработчиках работать не с контекстом (this), а с аргументом объекта ивента, который был передан свыше.

  Не полагаться на this при работе с объектами событий, а использовать первый параметр коллбека event.
  Работать только с тем, что приходит из события. JS позволяет вносить дополнительные данные в event.
  То есть не использовать "this.value". Вместо этого получать данные через объект события "e.currentTarget.value".
  Плохо:

  ```javascript
  handleButtonClick() {
   const buttonWidth = $(this).width();
   // ...
  }
  ```

  Хорошо:

  ```javascript
  handleButtonClick(event) {
   const buttonWidth = $(event.currentTarget).width();
   // ...
  }
  ```

  Если все же надо работать с this, то используйте стрелочные функции.

<a name="1.12"></a>

- [1.12](#1.12) Стараться по максимуму избегать циклов и использовать встроенные методы массивов.

  `.map`, `.filter` и тд обычно гораздо проще читаются, плюс функцию обработки одного элемента можно вынести и многократно использовать в разных местах.

<a name="1.13"></a>

- [1.13](#1.13) Не использовать литералы из бизнес-логики напрямую - надо создавать объект с константами.

  Если в бизнес-логике есть какой-то параметр, то надо создать где-то переменную, желательно в специальном месте для конфига, туда выносить все фиксированные значения, а в коде использовать их только по именам.

  Можно:

  ```javascript
   if (status === ordersModule.ACTIVE_STATUS) {...}
  ```

  Нельзя:

  ```javascript
   if (status === 'active') {...}
  ```

<a name="1.14"></a>

- [1.14](#1.14) Форматирование размещения импортов.

  Импорты объединяются в секции, секции разделяются переносом строки.
  Для фронта выделяются три секции (в таком порядке размещения):

    - Абсолютные импорты из node_modules;
    - Абсолютные импорты из src;
    - Относительные импорты, отсортированные в порядке убывания переходов на более верхний уровень в дереве пути (через ../).

      Например:

  ```javascript
  import * as React from "react";
  import block from "bem-cn";
  import { connect, Dispatch } from "react-redux";
  import { bindActionCreators } from "redux";
  import { arrayPush } from "redux-form";

  import { Modal } from "shared/view/elements";
  import { IPreset } from "shared/types/models";
  import { IAppReduxState } from "shared/types/app";
  import { actions as notificationActions } from "services/notification";
  import { selectors as configSelectors } from "services/config";

  import { actions, selectors } from "../../../redux";
  import { managePresetsFormEntry } from "../../../redux/reduxFormEntries";
  import { Presets } from "../../components/ManagePresets";
  import "./ManagePresets.scss";
  ```

  Также, для любого поддерева элемента пути не должно быть такого поддерева, импорты которого разделяются другим поддеревом такой же глубины.
  Например:
  Импорты поддерева `shared` (глубина 1) разделяются импортом поддерева services.

  ```javascript
  import { IModel } from "shared/types/models";
  import { i18nConnect } from "services/i18n";
  import { Component } from "shared/view/components";
  ```

  Правильно будет так:

  ```javascript
  import { IModel } from "shared/types/models";
  import { Component } from "shared/view/components";
  import { i18nConnect } from "services/i18n";
  ```

  Или в:

  ```javascript
  import { IAppReduxState } from "shared/types/app";
  import { Component } from "shared/view/components";
  import { IModel } from "shared/types/models";
  import { i18nConnect } from "services/i18n";
  ```

  импорты поддерева `shared/types` (глубина 2) разделяются импортом поддерева `shared/view`. Правильно будет так:

  ```javascript
  import { IAppReduxState } from "shared/types/app";
  import { IModel } from "shared/types/models";
  import { Component } from "shared/view/components";
  import { i18nConnect } from "services/i18n";
  ```

<a name="1.15"></a>

- [1.15](#1.15) Экспорты держать в конце файла.

  Плохо:

  ```javascript
  export class Foo {
    // ...
  }
  export class Bar {
    // ...
  }
  // finita la comedia
  ```

  Хорошо:

  ```javascript
  class Foo {
    // ...
  }
  class Bar {
    // ...
  }
  export { Foo, Bar };
  ```

<a name="1.16"></a>

- [1.16](#1.16) Старый код надо удалять, а не комментировать. Если он понадобится в дальнейшем, всегда можно будет посмотреть в истории коммитов.

  Это в первую очередь предназначено для ваших коллег - большие куски лишнего кода сбивают с толку, мешают поиску через `ctrl+F`, заставляют иногда отвлекаться на изучение кода. Так что лучше его скрыть в истории изменений.

<a name="1.17"></a>

- [1.17](#1.17) Все изменения в стилях, которые можно сделать через переключение классов у элемента, надо делать через добавление/удаление классов, а не простановку стилей у DOM-элементов. Так, например, можно переключать видимость элемента. Однако для непрерывно изменяющихся численных значений так сделать уже не получится, как например при изменении свойства `top` при скролле страницы, поэтому тут придётся все-таки проставлять напрямую у элемента значение в css-свойстве.\*\*;

  Это не только увеличит производительность (потому что за раз вы примените сразу все стили от нового класса), но и поможет потом переписать стили из css нормальным способом, потому что иначе стили будут инлайновые и из css их нельзя будет переопределить, кроме как через `!important`.

<a name="1.18"></a>

- [1.18](#1.18) Код должен быть без орфографических ошибок. Имена переменных, функций, комментарии должны быть написаны правильно.

  Обычно, чтобы избежать большинства ошибок, используют расширения для `IDE`, для `vscode` например есть хорошее расширение [Code Spell Checker](https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker).

<a name="1.19"></a>

- [1.19](#1.19) Вся работа со службами браузера (`navigator services`, `cookie`, `localStorage`) должна быть обернута в try/catch, т.к. это внешние по отношению к нашему коду службы, от которых не ясно, чего ждать. На спеки тут полагаться не стоит, т.к. есть и новые движки, которые имеют в том числе баги в своих сорцах.

  В сафари если включен режим инкогнито или если в браузере стоит блокировка `cookie`, то браузер будет райзить ошибку. Поэтому если ее не отловить, приложение посыпется :)

<a name="1.20"></a>

- [1.20](#1.20) Не расширять стандартные классы, такие как Array, Error, Map и другие, потому что вот [почему](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work).


<a name="2"></a>

## Именование переменных

<a name="2.1"></a>

- [2.1](#2.1) Именовать переменные по смыслу.

  Имя переменной должно полно и точно описывать сущность и ее предназначение.

  Имеется в виду не использовать в качестве имен date, result, array. Например, для текущей даты лучше использовать переменную today, а не date, для списка студентов лучше подойдет students а не array.

<a name="2.2"></a>

- [2.2](#2.2) Старайтесь не давать переменным слишком длинные имена.

  Как правило, чтобы раскрыть смысл переменной, достаточно около трех слов (10-15 символов). Переменные всегда используются в каком-то контексте, исходя из которого некоторые детали могут опускаться. Например, объект класса слайдера может содержать поле range, в котором содержится диапазон слайдера. Нет нужды называть это поле `sliderRange`, поскольку и так очевидно, что это относится к слайдеру. Длинные имена усложняют чтение кода и их следует использовать только тогда, когда более короткое имя неоднозначно и несет в себе слишком мало информации (учитывая контекст, о котором сказано выше) для понимания ее смысла.

<a name="2.3"></a>

- [2.3](#2.3) При именовании переменных использовать `camelCase`, так как это принято в JavaScript комьюнити.

  Если данные, которые приходят "со стороны" (например с бекенда), не в `camelCase` формате (`snake_case` или любой другой), имеет смысл нормализировать ключи для консистентности.

<a name="2.4"></a>

- [2.4](#2.4) Присваивайте булевым переменным имена, подразумевающие значение `true` или `false`.

  В основном мы юзаем префиксы в начале переменных: `is/are`, `has`, `with`. Порой название `boolean` переменной можно сформулировать как утверждение: `selectedColsWereChanged`, что позволит сделать код более читаемым и понятным.

  ```javascript
  if (selectedColsWereChanged) { // do something... }
  ```

  С другой стороны никто вас не ограничивает в использовании других конструкций английского языка: `will, should, etc`. которые позволят корректно выразить то, что вы хотите выразить в коде.

<a name="2.5"></a>

- [2.5](#2.5) Использовать утвердительную форму булевых переменных.

  Имена, основанные на отрицании (такие как `notFound`, `notdone` и `notSuccessful`), при выполнении над переменной операции отрицания становятся куда менее понятны, например:

  ```javascript
  if (not notFound) {..}
  ```

  Подобные имена следует заменить на `found`, `done` и `processingComplete`, выполняя отрицание переменных в случае надобности. Так что для проверки нужного значения вы использовали бы выражение `found`, а не `not notFound`.

<a name="2.6"></a>

- [2.6](#2.6) Используйте объясняющие переменные.

  Плохо:

  ```javascript
  const address = "One Infinite Loop, Cupertino 95014";
  const cityZipCodeRegex = /^[^,\\]+[,\\\s]+(.+?)\s*(\d{5})?$/;
  saveCityZipCode(
    address.match(cityZipCodeRegex)[1],
    address.match(cityZipCodeRegex)[2]
  );
  ```

  Хорошо:

  ```javascript
  const address = "One Infinite Loop, Cupertino 95014";
  const cityZipCodeRegex = /^[^,\\]+[,\\\s]+(.+?)\s*(\d{5})?$/;
  const [_, city, zipCode] = address.match(cityZipCodeRegex) ?? [];
  saveCityZipCode(city, zipCode);
  ```


<a name="2.7"></a>

- [2.7](#2.7) Имя константы должно характеризовать абстрактную сущность, представляемую константой, а не конкретное значение.

  Например, нужна константа, отражающая количество рабочих дней:

  плохо: `FIVE`  
  хорошо: `WORK_DAYS.`


<a name="3"></a>

## Именование функций

<a name="3.1"></a>

- [3.1](#3.1) Все имена функций, за редкими исключениями (например, следование уже устоявшемуся соглашению в рамках какой-нибудь библиотеки), должны начинаться с глаголов.

<a name="3.2"></a>

- [3.2](#3.2) Функции высшего порядка, возвращающие функции, следует именовать по шаблону make + .\* + отглагольное существительное, где .\* — опциональный, синтаксически корректный набор слов уточняющий предназначение функции.

  Пример: `makeButtonClickHandler`.

<a name="3.3"></a>

- [3.3](#3.3) Обработчики событий.

  Под событиями понимаются не только DOM-события, но и какие-то абстрактные события, которые обрабатываются с помощью коллбэков, вроде `onClose` модального окна или `onLogin` формы логина):

    - Обработчики событий для БЭМ-элементов, а также для компонент, вложенных в БЭМ-элементы, именуются по шаблону `handleElementNameEventName`, где `ElementName` - имя БЭМ-элемента.

      Примеры:

      ```JSX
      <button className="block__cancel-button" onClick={this.handleCancelButtonClick} />
      <div className="block__first-name-input">
        <Input onChange={this.handleFirstNameInputChange} />
      </div>
      ```

      Если компонента не вложена в БЭМ-элемент, то `ElementName` в данном случае стоит выбирать по смыслу, исходя из контекста\*\* (причем, поскольку БЭМ-элементы именуются по похожему принципу, то и БЭМ-элемент в данном случае назывался бы, скорее всего, так же):

      ```JSX
      <div className="block">
        <Button onClick={this.handleCancelButtonClick} />
        <Input onChange={this.handleFirstNameInputChange} />
      </div>
      ```

      Обоснование: именуя колбэки по такому шаблону, мы не будем тратить время на придумывание имени и всегда можем понять предназначение колбэка лишь посмотрев на его имя.

      **Примечание**: в случаях, когда тело обработчика используется где-то ещё, то его следует выносить в отдельную функцию: например, обработчик `handleButtonClick`, выводящий список итемов, может передаваться только в пропс `onClick` БЭМ-элемента "button"; если же требуется вывести список итемов еще в каких-то других случаях, то следует сделать следующим образом:

      ```JSX
      handleButtonClick() {
        showItems();
      }
  
      showItems() {
        // ...
      }
      ```

<a name="4"></a>

## Архитектура

<a name="4.1"></a>

- [4.1](#4.1) Модульность - наше все!

  Обязательно дробить приложение на разные модули.

  В рамках одного модуля описывать только схожий функционал, который объединен смыслом. Это называется [связность](<https://ru.wikipedia.org/wiki/%D0%A1%D0%B2%D1%8F%D0%B7%D0%BD%D0%BE%D1%81%D1%82%D1%8C_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)>). Обратная сторона медали - [зацепление](<https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D1%86%D0%B5%D0%BF%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)>), когда модули друг от друга сильно зависят - этого как раз надо избегать. То есть общий принцип - модули надо разбить так, чтобы внутри каждого модуля была максимальная схожесть области работы, а между модулями было максимальное различие. Например, в статистике сегмантация выполняется по таким же принципам, все группы должны состоять из максимально похожих элементов и при этом максимально отличаться друг от друга :).

  Всё, что может быть использовано(типы, функции и т.д.) за пределами модуля выносить в глобальную видимость в виде сервиса, файла с типами и прочее.
<a name="4.2"></a>

- [4.2](#4.2) В рамках модуля четко делить на слои и не мешать логику работы с DOM и работу с данными (например, ajax-запросы).

  Вообще всю работу с самими данными максимально отделять от работы с DOM и обработке событий пользователя (клики, сабмиты и тд).

<a name="4.3"></a>

- [4.3](#4.3) Избегать мутаций одной переменной сразу в нескольких функциях.

  Пример плохого кода:

  ```javascript
  const box = {};

  function addBall(box) {
    box.ball = { radius: 2 };
  }

  function addFood(box) {
    box.food = { carrot: 4 };
  }

  function addShoes(box) {
    box.shoes = { sneakers: 2 };
  }

  addBall(box);
  addFood(box);
  addShoes(box);
  ```

  Из-за таких действий область использования переменной становится слишком большой и тяжело понять, какая именно функция и когда изменила переменную. Когда произойдет ошибка в 10-ой функции, будет непонятно почему box содержит 5 пар кроссовок и 15 морковок.

  Используйте чистые функции, пересоздавайте объекты, а не мутируйте их, а еще лучше формализуйте все возможности изменить ваш объект.

<a name="4.4"></a>

- [4.4](#4.4) При написании класса все публичные методы объявляйте первыми, причем самым первым должен идти конструктор, все приватные методы группируйте по смыслу внизу класса

<a name="5"></a>

## Безопасность

- [Browser Security Handbook from Google](https://code.google.com/archive/p/browsersec/wikis/Main.wiki).
- [HTML5 Security Cheatsheet](https://html5sec.org/#javascript).
- [Web Security Basics](https://github.com/vasanthk/web-security-basics).
